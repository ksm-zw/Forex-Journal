{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Forex-Journal/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\n// Safe Prisma provider: only instantiate Prisma when DATABASE_URL looks valid for supported providers.\n// This prevents dev servers and serverless hosts without DB configured from crashing.\nlet prisma: PrismaClient | null = null;\n\ntry {\n  const url = process.env.DATABASE_URL || '';\n  const normalized = url.trim();\n  const isSqlite = normalized.startsWith('file:');\n  const isPg = normalized.startsWith('postgres') || normalized.startsWith('postgresql:');\n\n  if (normalized && (isSqlite || isPg)) {\n    prisma = new PrismaClient();\n  } else {\n    // No valid DATABASE_URL set; leave prisma null so callers can fallback\n    console.warn('Prisma disabled: DATABASE_URL not set to sqlite or postgres. Falling back to demo/resilient behavior.');\n  }\n} catch (err) {\n  console.warn('Failed to initialize Prisma client:', err);\n  prisma = null;\n}\n\nexport { prisma };\n"],"names":[],"mappings":";;;;AAAA;;AAEA,uGAAuG;AACvG,sFAAsF;AACtF,IAAI,SAA8B;AAElC,IAAI;IACF,MAAM,MAAM,QAAQ,GAAG,CAAC,YAAY,IAAI;IACxC,MAAM,aAAa,IAAI,IAAI;IAC3B,MAAM,WAAW,WAAW,UAAU,CAAC;IACvC,MAAM,OAAO,WAAW,UAAU,CAAC,eAAe,WAAW,UAAU,CAAC;IAExE,IAAI,cAAc,CAAC,YAAY,IAAI,GAAG;QACpC,SAAS,IAAI,sMAAY;IAC3B,OAAO;QACL,uEAAuE;QACvE,QAAQ,IAAI,CAAC;IACf;AACF,EAAE,OAAO,KAAK;IACZ,QAAQ,IAAI,CAAC,uCAAuC;IACpD,SAAS;AACX"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Forex-Journal/src/lib/analytics.ts"],"sourcesContent":["/**\n * Analytics Utilities for Forex Trading Research Lab\n * Calculate metrics, analyze patterns, and generate insights from trade data\n */\n\nimport { Prisma } from '@prisma/client';\n\n/**\n * Calculate metrics for a specific strategy\n */\nexport function calculateMetricsByStrategy(trades: any[]) {\n  if (!trades.length) {\n    return {\n      totalTrades: 0,\n      closedTrades: 0,\n      wins: 0,\n      losses: 0,\n      breakeven: 0,\n      winRate: 0,\n      totalRR: 0,\n      avgWin: 0,\n      avgLoss: 0,\n      expectancy: 0,\n      profitFactor: 0,\n    };\n  }\n\n  const closed = trades.filter((t) => t.status === 'closed');\n  const wins = closed.filter((t) => t.outcome === 'WIN');\n  const losses = closed.filter((t) => t.outcome === 'LOSS');\n  const breakeven = closed.filter((t) => t.outcome === 'BREAKEVEN');\n\n  const totalRR = trades.reduce((sum, t) => sum + (t.riskRewardRatio || 0), 0);\n  const totalWinRR = wins.reduce((sum, t) => sum + (t.riskRewardRatio || 0), 0);\n  const totalLossAmount = Math.abs(losses.reduce((sum, t) => sum + (t.profitLoss || 0), 0));\n\n  const winRate = closed.length > 0 ? (wins.length / closed.length) * 100 : 0;\n  const avgWin = wins.length > 0 ? totalWinRR / wins.length : 0;\n  const avgLoss = losses.length > 0 ? (totalLossAmount / losses.length) * -1 : 0;\n  const profitFactor = Math.abs(avgLoss) > 0 ? avgWin / Math.abs(avgLoss) : 0;\n\n  const expectancy =\n    wins.length > 0 && losses.length > 0\n      ? (wins.length * avgWin - losses.length * Math.abs(avgLoss)) / (wins.length + losses.length)\n      : 0;\n\n  return {\n    totalTrades: trades.length,\n    closedTrades: closed.length,\n    wins: wins.length,\n    losses: losses.length,\n    breakeven: breakeven.length,\n    winRate: parseFloat(winRate.toFixed(2)),\n    totalRR: parseFloat(totalRR.toFixed(2)),\n    avgWin: parseFloat(avgWin.toFixed(2)),\n    avgLoss: parseFloat(avgLoss.toFixed(2)),\n    expectancy: parseFloat(expectancy.toFixed(2)),\n    profitFactor: parseFloat(profitFactor.toFixed(2)),\n  };\n}\n\n/**\n * Calculate rule violation impact on profitability\n */\nexport function calculateRuleViolationImpact(\n  trades: any[],\n  tradeRuleCompliance: any[]\n) {\n  let hypotheticalPL = 0;\n  let actualPL = 0;\n  const ruleViolationCounts: Record<string, number> = {};\n  const ruleViolationPL: Record<string, number> = {};\n\n  for (const trade of trades) {\n    actualPL += trade.profitLoss || 0;\n\n    const violations = tradeRuleCompliance.filter(\n      (c) => c.trade_id === trade.id && !c.followed\n    );\n\n    if (violations.length === 0) {\n      hypotheticalPL += trade.profitLoss || 0;\n    }\n\n    for (const violation of violations) {\n      const ruleId = violation.rule_id;\n      ruleViolationCounts[ruleId] = (ruleViolationCounts[ruleId] || 0) + 1;\n      ruleViolationPL[ruleId] = (ruleViolationPL[ruleId] || 0) + (trade.profitLoss || 0);\n    }\n  }\n\n  return {\n    actualPL: parseFloat(actualPL.toFixed(2)),\n    hypotheticalPL: parseFloat(hypotheticalPL.toFixed(2)),\n    impactFromViolations: parseFloat((actualPL - hypotheticalPL).toFixed(2)),\n    ruleViolationCounts,\n    ruleViolationPL,\n  };\n}\n\n/**\n * Group trades by time period\n */\nexport function groupTradesByPeriod(\n  trades: any[],\n  periodType: 'day' | 'week' | 'month' | 'quarter' | 'half' | 'year'\n) {\n  const groups: Record<string, any[]> = {};\n\n  for (const trade of trades) {\n    const date = new Date(trade.entryTime);\n    let key: string;\n\n    switch (periodType) {\n      case 'day':\n        key = date.toISOString().split('T')[0];\n        break;\n      case 'week':\n        const weekStart = new Date(date);\n        weekStart.setDate(date.getDate() - date.getDay());\n        key = weekStart.toISOString().split('T')[0];\n        break;\n      case 'month':\n        key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n        break;\n      case 'quarter':\n        const quarter = Math.ceil((date.getMonth() + 1) / 3);\n        key = `${date.getFullYear()}-Q${quarter}`;\n        break;\n      case 'half':\n        const half = date.getMonth() < 6 ? 'H1' : 'H2';\n        key = `${date.getFullYear()}-${half}`;\n        break;\n      case 'year':\n        key = String(date.getFullYear());\n        break;\n    }\n\n    if (!groups[key]) {\n      groups[key] = [];\n    }\n    groups[key].push(trade);\n  }\n\n  return groups;\n}\n\n/**\n * Calculate metrics for a period\n */\nexport function periodMetrics(trades: any[]) {\n  const metrics = calculateMetricsByStrategy(trades);\n  return {\n    period: {\n      startDate: trades.length > 0 ? trades[0].entryTime : null,\n      endDate: trades.length > 0 ? trades[trades.length - 1].entryTime : null,\n    },\n    ...metrics,\n  };\n}\n\n/**\n * Analyze timeframe sequence performance\n */\nexport function timeframeSequenceAnalysis(\n  trades: any[],\n  timeframeCompliance: any[]\n) {\n  const sequences: Record<string, any[]> = {};\n\n  for (const trade of trades) {\n    const compliance = timeframeCompliance.filter((c) => c.trade_id === trade.id);\n    const sequence = compliance.map((c) => c.role_type).join('→') || 'unknown';\n\n    if (!sequences[sequence]) {\n      sequences[sequence] = [];\n    }\n    sequences[sequence].push(trade);\n  }\n\n  const analysis: Record<string, any> = {};\n  for (const [sequence, sequenceTrades] of Object.entries(sequences)) {\n    analysis[sequence] = calculateMetricsByStrategy(sequenceTrades);\n  }\n\n  return analysis;\n}\n\n/**\n * Generate rule-based summary insights\n */\nexport function generateRuleBasedSummary(\n  metrics: any,\n  strategies: any[],\n  tradeData: any\n) {\n  const insights = [];\n\n  // Win rate analysis\n  if (metrics.winRate > 60) {\n    insights.push(\n      `Excellent win rate of ${metrics.winRate}% — focus on consistency and maintaining edge.`\n    );\n  } else if (metrics.winRate < 30) {\n    insights.push(\n      `Win rate is ${metrics.winRate}% — review entry logic and rule adherence.`\n    );\n  }\n\n  // Expectancy analysis\n  if (metrics.expectancy > 1.0) {\n    insights.push(\n      `Positive expectancy of ${metrics.expectancy}R per trade — the strategy is profitable.`\n    );\n  } else if (metrics.expectancy < 0) {\n    insights.push(\n      `Negative expectancy of ${metrics.expectancy}R — strategy needs refinement.`\n    );\n  }\n\n  // Rule adherence\n  if (tradeData.ruleViolationImpact) {\n    const impact = tradeData.ruleViolationImpact.impactFromViolations;\n    if (impact < 0) {\n      insights.push(\n        `Rule violations cost you ${Math.abs(impact).toFixed(2)}R — stricter discipline needed.`\n      );\n    }\n  }\n\n  return {\n    narrative: insights.join(' '),\n    feedback: {\n      stop: [],\n      continue: [],\n      experiment: [],\n    },\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 255, "column": 0}, "map": {"version":3,"sources":["file:///workspaces/Forex-Journal/src/app/api/analytics/period-analysis/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport {\n  groupTradesByPeriod,\n  periodMetrics,\n} from '@/lib/analytics';\n\n/**\n * GET /api/analytics/period-analysis\n * Analyze trades by time period (day, week, month, quarter, half, year)\n * Query params: ?period=month (default: month)\n */\nexport async function GET(request: NextRequest) {\n  try {\n    const userIdentifier = request.headers.get('x-user-id') || 'demo@forex-research.com';\n    const url = new URL(request.url);\n    const period = (url.searchParams.get('period') || 'month') as\n      | 'day'\n      | 'week'\n      | 'month'\n      | 'quarter'\n      | 'half'\n      | 'year';\n\n    if (!prisma) {\n      return NextResponse.json(\n        { error: 'Database not available' },\n        { status: 503 }\n      );\n    }\n\n    let user = await prisma.user.findUnique({\n      where: { email: userIdentifier },\n    });\n\n    if (!user) {\n      user = await prisma.user.findUnique({\n        where: { id: userIdentifier },\n      });\n    }\n\n    if (!user) {\n      return NextResponse.json({ error: 'User not found' }, { status: 404 });\n    }\n\n    const trades = await prisma.trade.findMany({\n      where: { userId: user.id },\n      include: {\n        rule_compliance: true,\n        timeframe_compliance: true,\n      },\n      orderBy: { entryTime: 'asc' },\n    });\n\n    const grouped = groupTradesByPeriod(trades, period);\n    const analysis: Record<string, any> = {};\n\n    for (const periodKey in grouped) {\n      analysis[periodKey] = periodMetrics(grouped[periodKey]);\n    }\n\n    return NextResponse.json({\n      success: true,\n      period,\n      analysis,\n    });\n  } catch (error) {\n    console.error('Error analyzing periods:', error);\n    return NextResponse.json(\n      { error: 'Failed to analyze periods' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAUO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,iBAAiB,QAAQ,OAAO,CAAC,GAAG,CAAC,gBAAgB;QAC3D,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;QAC/B,MAAM,SAAU,IAAI,YAAY,CAAC,GAAG,CAAC,aAAa;QAQlD,IAAI,CAAC,gIAAM,EAAE;YACX,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAyB,GAClC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,OAAO;YAAe;QACjC;QAEA,IAAI,CAAC,MAAM;YACT,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;gBAClC,OAAO;oBAAE,IAAI;gBAAe;YAC9B;QACF;QAEA,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,MAAM,SAAS,MAAM,gIAAM,CAAC,KAAK,CAAC,QAAQ,CAAC;YACzC,OAAO;gBAAE,QAAQ,KAAK,EAAE;YAAC;YACzB,SAAS;gBACP,iBAAiB;gBACjB,sBAAsB;YACxB;YACA,SAAS;gBAAE,WAAW;YAAM;QAC9B;QAEA,MAAM,UAAU,IAAA,gJAAmB,EAAC,QAAQ;QAC5C,MAAM,WAAgC,CAAC;QAEvC,IAAK,MAAM,aAAa,QAAS;YAC/B,QAAQ,CAAC,UAAU,GAAG,IAAA,0IAAa,EAAC,OAAO,CAAC,UAAU;QACxD;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}